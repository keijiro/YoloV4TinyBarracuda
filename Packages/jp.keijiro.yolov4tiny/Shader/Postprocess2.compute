// Second stage postprocessing (overlap removal)

#pragma kernel Postprocess2

#include "Common.hlsl"

// Input
StructuredBuffer<Detection> Input;
RWStructuredBuffer<uint> InputCount; // Only used as a counter
float IouThreshold;
uint ClassCount;

// Output
AppendStructuredBuffer<Detection> Output;

// Local arrays for data cache
groupshared Detection _entries[MAX_DETECTION];
groupshared bool _flags[MAX_DETECTION];

[numthreads(1, 1, 1)]
void Postprocess2(uint3 id : SV_DispatchThreadID)
{
    // Initialize data cache arrays
    uint entry_count = min(MAX_DETECTION, InputCount.IncrementCounter());
    if (entry_count == 0) return;

    // Apply for each class
    for (uint c = 0; c < ClassCount; c++)
    {
        // Separate detections by class
        uint count = 0;
        for (uint i = 0; i < entry_count; i++)
        {
            if (Input[i].classIndex != c) continue;

            // Store the detection in the cache arrays
            _entries[count] = Input[i];
            _flags[count] = true;
            count++;
        }

        if (count == 0) continue;

        // Sort detections by score
        for (i = 0; i < count - 1; i++)
        {
            for (uint j = i + 1; j < count; j++)
            {
                // Score comparison
                if (_entries[i].score < _entries[j].score)
                {
                    Detection temp = _entries[i];
                    _entries[i] = _entries[j];
                    _entries[j] = temp;
                }
            }
        }

        // Overlap test permutation
        for (i = 0; i < count - 1; i++)
        {
            if (!_flags[i]) continue;

            for (uint j = i + 1; j < count; j++)
            {
                if (!_flags[j]) continue;

                // Overlap test
                if (CalculateIOU(_entries[i], _entries[j]) > IouThreshold)
                    _flags[j] = false;
            }
        }

        // Output aggregation
        for (i = 0; i < count; i++)
            if (_flags[i]) Output.Append(_entries[i]);
    }
}
